# **反射**

**反射很强大,后面学的框架很多功能全是通过反射实现的**

##### **获取字节码对象的三种方式:**

```java
// 方式1
Class.forName("包的全限定类名"); // 大量框架中使用
// 方式2
对象.getClass();
// 方式3
类名.class 
// 可以获取基本类型int.class  int[]数组和int类型的字节码对象不一样
```



##### 通过字节码对象获取构造器/方法/字段:

```java
//获取所有公共构造器
clz.getConstructors(); 

//获取所有构造器/无视访问修饰符
clz.getDeclaredConstructors(); 

//获取指定构造器/无视访问修饰符
clz.getDeclaredConstructor("形参字节码类型","形参字节码类型"); 

 创建对象是newinstance();
 // 重点
 调用方法是invoke(对象,方法形参); //如果是调用静态方法对象传null;

判断对象的真实类型 包括父类
 对象 instanceof User
 如果是Object类型调用getClass()可以获取当前真实类型字节码;
```

大概都差不多,万变不离其宗,方法和字段也一样

**重点:** 

**如果是private修饰的,需要开启访问权限调用**

**setAccessible(true)方法设置为true**

**用完记得改回false**







# 内省机制

**前提需要类遵循javaBean规范**

**我们开发中常常需要操作类的属性,而使用反射获取起来非常麻烦,所有jdk给我们提供了一个api  让我们更方便的操作属性**

##### **内省的人口 : introspector **类

```java
// 获取beanInfo 
BeanInfo beanInfo = Introspector.getBeanInfo("字节码", "不包括"); // 区间获取,含头不含尾

//获取属性
 PropertyDescriptor[] pds = beanInfo.getPropertyDescriptors();

// 最后迭代获取所有属性的读方法和写方法
```

##### **javaBean类的属性转Map**

**属性名=属性值**

**key=value**





# **注解**

定义注解直接参照 @Override

```java
@Target({ElementType.METHOD})	// 决定可以贴在哪里
@Retention(RetentionPolicy.RUNTIME) // 必须是运行时时类
public @interface 自定义注解 {
    
    // 类型只能是基本类型,String,Class,注解类型,枚举,和这些类型的一维数组
    // 贴属性时要写的属性只有一个,属性名字还是value,可以省略名字直接给值
    // 如果多个值需要花括号括起来,按照数组静态初始化的{}方式
    String delete(); // 可以说是抽象方法(方便理解),不能有方法体
    int test() default 1; // 设置默认值贴标签时可以不给值
}
```

**自定义注解需要三个条件:**

**1>注解本身**

**2>被贴的程序元素**

**3>第三方实现类,赋予注解功能**

##### **实现:**

**第三方程序使用反射,获取被贴注解的元素,并赋予其功能**











